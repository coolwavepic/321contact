<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>321 Contact — Enhanced v7 (Fixed)</title>
<style>
  :root{
    /* GAME DIMENSIONS */
    --w:1280px;
    /* Keep playfield height constant (580) while header varies:
       total game height = header + 70 (old extra spacing) + 180 (controls) + 580 (playfield) */
    --header-h: 200px;         /* <— adjust this to make the top screen taller */
    --header-gap: 10px;        /* spacing below header */
    --h: calc(var(--header-h) + 830px);
      /* NEW: actual jackpot bar height + spacing to playfield */
  --jackpot-h: 80px;   /* tweak if your jackpot boxes render taller/shorter */
  --pf-gap: 12px;      /* tiny breathing room under jackpots */
 /* TOTAL GAME HEIGHT = header + header-gap + jackpots + pf-gap + controls(180) + playfield(580) */
  --h: calc(var(--header-h) + var(--header-gap) + var(--jackpot-h) + var(--pf-gap) + 760px);
    /* COLORS */
    --accent:#00d2ff;--bg:#05070c;--panel:#0b1328;--line:#40c8ff;--text:#e8f3ff;--win:#2ecc71;--warn:#ffaa00;
    --tease:#4df3ff; --tease-strong:#7ff9ff; --border-glow:#49b9ff;
    --mini:#aa4caf; --minor:#2196F3; --major:#00ff0d; --grand:#E91E63;
  }

  *{box-sizing:border-box}
  body {
      margin: 0;
      background: radial-gradient(50% 60% at 50% 40%, #0e1a3a, #05070c);
      min-height: 100vh;
      display: flex;
      flex-direction: column; /* stack top to bottom */
      align-items: center;    /* still center horizontally */
      justify-content: flex-start; /* start at the top */
      color: var(--text);
      font-family: Arial, Helvetica, sans-serif;
  }

  .game{
    width:min(100vw,var(--w));
    height:min(100vh,var(--h));      /* <— now grows with header */
    position:relative;border-radius:16px;overflow:hidden;
    border:4px solid #0a0f1e;box-shadow:0 40px 90px rgba(0,0,0,.6) inset, 0 14px 40px rgba(0,0,0,.6)
  }

  /* HEADER */
.header {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    width: var(--w);
    height: var(--header-h);
    overflow: hidden; /* ensure media doesn't spill out */
    z-index: 6;
}

.header img,
.header video {
    width: 100%;
    height: 100%;
    object-fit: cover; /* keeps aspect correct, fills space */
    display: block;
}

.header h1 {
    display: none; /* hide old text */
}

  
  .title{
    font-weight:900;font-size:24px;text-shadow:0 1px 0 rgba(255,255,255,.08),0 -1px 0 rgba(0,0,0,.6)
  }

  /* JACKPOT DISPLAY */
.jackpots {
    position: absolute;
    top: calc(var(--header-h) + var(--header-gap));
    left: 0;
    width: var(--w);
    height: 90px; /* match your video height */
    overflow: hidden;
    z-index: 5;
}

.jackpots video {
    width: 1270px;
    height: 90px;
    object-fit: fill; /* fills the space without stretching */
    display: block;
}

  .jackpot{
    background:linear-gradient(135deg,#1a1a2e,#0f0f1e);border:2px solid;border-radius:10px;
    padding:8px 16px;text-align:center;min-width:120px;font-weight:900;
    box-shadow:0 4px 12px rgba(0,0,0,.5)
  }
  .jackpot.mini{border-color:var(--mini);color:#dc69cd}
  .jackpot.minor{border-color:var(--minor);color:#a3d5ff}
  .jackpot.major{border-color:var(--major);color:#43d755}
  .jackpot.grand{border-color:var(--grand);color:#c93b3b}
  .jackpot-label{font-size:20px;opacity:.8}
  .jackpot-value{font-size:40px}

  /* JACKPOT CELEBRATION OVERLAY */
  .jackpot-celebration {
    position: absolute;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.063);
    z-index: 80;
    flex-direction: column;
  }
  .jackpot-celebration.show { display: flex; }

  .jackpot-zoom {
    width: 720px; max-width: 86vw; min-height: 300px;
    background: radial-gradient(120% 120% at 50% 0%, #131327 0%, #0b0b1a 50%, #090915 100%);
    border: 3px solid; border-radius: 20px; padding: 34px 42px; text-align: center; font-weight: 900;
    box-shadow: 0 10px 40px rgba(0,0,0,.65), inset 0 0 24px rgba(255,255,255,.06);
    position: relative; overflow: hidden; animation: jackpotZoomIn 0.45s ease-out; will-change: transform;
  }
  .jackpot-zoom.mini  { border-color: var(--mini);  box-shadow: 0 8px 28px rgba(170,76,175,.35), inset 0 0 24px rgba(170,76,175,.18); }
  .jackpot-zoom.minor { border-color: var(--minor); box-shadow: 0 8px 28px rgba(33,150,243,.35), inset 0 0 24px rgba(33,150,243,.18); }
  .jackpot-zoom.major { border-color: var(--major); box-shadow: 0 8px 28px rgba(0,255,13,.35),   inset 0 0 24px rgba(0,255,13,.18); }
  .jackpot-zoom.grand { border-color: var(--grand); box-shadow: 0 8px 28px rgba(233,30,99,.35),  inset 0 0 24px rgba(233,30,99,.18); }

  .jackpot-zoom::before {
    content: ""; position: absolute; inset: -2px; border-radius: 20px;
    background: conic-gradient(from 0deg, rgba(255,255,255,.18), transparent 30%, rgba(255,255,255,.18) 60%, transparent 100%);
    mix-blend-mode: screen; animation: jackpotShimmer 2.8s linear infinite; pointer-events: none;
  }
  .jackpot-label-big { font-size: 52px; margin-bottom: 12px; letter-spacing: 3px; text-transform: uppercase; text-shadow: 0 0 20px currentColor; }
  .jackpot-amount-big { font-size: 88px; margin-bottom: 10px; font-variant-numeric: tabular-nums lining-nums; text-shadow: 0 0 30px currentColor; }
  .jackpot-multiplier { font-size: 78px; color: #ffd700; margin-top: 12px; text-shadow: 0 0 15px #ffd700; }

  @keyframes jackpotZoomIn { 0%{transform:scale(.3);opacity:0} 50%{transform:scale(1.1)} 100%{transform:scale(1);opacity:1} }
  @keyframes jackpotShimmer { 0%,100%{transform:translateX(-100%) rotate(45deg)} 50%{transform:translateX(100%) rotate(45deg)} }


/* Jackpot overlay — FULLSCREEN by default */
#jackpotOverlay {
  position: absolute;
  inset: 0;            /* fill the entire game area */
  transform: none;     /* no centering transform */
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 800;        /* above reels/HUD as needed */
}

#jackpotOverlay.overlay-hidden { display: none; }
#jackpotOverlay.overlay-show   { display: block; }

/* Video sizing: cover to fill screen (may crop) or switch to contain to avoid any crop */
#jackpotOverlay #jackpotVideo { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; }
#jackpotOverlay #jackpotCounterMount { position:absolute; inset:0; display:grid; place-items:center; z-index:1; }


/* Optional: bring back the original strip mode when desired */
#jackpotOverlay.mode-strip {
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 1280px;
  height: 156px;
}

  /* BONUS SPIN WIN DISPLAY */
  .bonus-win-display {
    position: absolute; left: 50%; top: 40%; transform: translate(-50%, -50%);
    background: linear-gradient(135deg, #0a1430, #1a2857); border: 3px solid #ffd700; border-radius: 15px;
    padding: 25px 35px; text-align: center; font-weight: 900; box-shadow: 0 6px 25px rgba(0,0,0,.6);
    display: none; z-index: 70; min-width: 300px;
  }
  .bonus-win-display.show { display: block; animation: bonusWinPop .5s ease-out; }
  .bonus-win-label { font-size: 28px; color: #ffd700; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 15px #ffd700; }
  .bonus-win-amount { font-size: 48px; color: #fff; text-shadow: 0 0 20px rgba(255,255,255,.8); }
  @keyframes bonusWinPop { 0%{transform:translate(-50%,-50%) scale(.5);opacity:0} 60%{transform:translate(-50%,-50%) scale(1.1)} 100%{transform:translate(-50%,-50%) scale(1);opacity:1} }

  /* FREE SPIN COUNTER IMAGES */
  .fs-counter img { width: auto; height: 40px; object-fit: contain; }

  /* PLAYFIELD */
.playfield{
  position:absolute;
  inset: calc(var(--header-h) + var(--header-gap) + var(--jackpot-h) + var(--pf-gap)) 0 180px 0;
  perspective:1000px;
  transform-style:preserve-3d;
  display:flex;
  align-items:center;
  justify-content:center;
}
  .playfield-inner{
    width:100%; height:100%; position:relative; transform-style:preserve-3d;
    transition:transform 1.2s ease-in-out; transform-origin:center center
  }
  .playfield-inner.flipped{transform:rotateY(180deg)}
  .playfield-inner.zoomed{transform:scale(0.65)}
  .playfield-inner.zoomed.flipped{transform:scale(0.65) rotateY(180deg)}
  @keyframes pfPulse{0%{transform:scale(1)}45%{transform:scale(0.965)}100%{transform:scale(1)}}
  .playfield-inner.bonus-pulse{animation:pfPulse 650ms ease-in-out;}

  /* PRECOG VIDEO OVERLAY */
  .precog-overlay{ position:absolute; inset:0; display:none; align-items:center; justify-content:center; z-index:50; pointer-events:none }
  .precog-overlay.show{display:flex}
  .precog-overlay video{ width:100%; height:100%; object-fit:fill; opacity:0.9 }
  .game.precog-gaffe{animation:precogFlash 600ms ease}
  @keyframes precogFlash{0%{box-shadow:0 40px 90px rgba(0,0,0,.6) inset,0 14px 40px rgba(0,0,0,.6),0 0 0 0 rgba(255,165,0,0)}30%{box-shadow:0 40px 90px rgba(0,0,0,.4) inset,0 14px 40px rgba(0,0,0,.4),0 0 32px 10px rgba(255,0,0,.85)}100%{box-shadow:0 40px 90px rgba(0,0,0,.6) inset,0 14px 40px rgba(0,0,0,.6),0 0 0 0 rgba(255,165,0,0)}}

  /* BASE GAME SIDE */
  .side-base{position:absolute;inset:0;backface-visibility:hidden}

  /* BONUS SIDE (flipped) */
  .side-bonus{
    position:absolute;inset:0;backface-visibility:hidden;transform:rotateY(180deg);
    background:radial-gradient(circle at 50% 50%,#2a0845,#0a0515); border-radius:12px; padding:20px
  }

  .nodes{position:absolute;inset:0}
  .node{position:absolute;width:260px;height:260px;display:grid;place-items:center}
  .r1{left:10%;top:5%}
  .r2{right:10%;top:5%}
  .r3{left:50%;transform:translateX(-50%);top:38%}

  svg.wires{ position:absolute; inset:0; pointer-events:none;
    filter: drop-shadow(0 0 12px rgba(0,100,255,0.8)) drop-shadow(0 0 20px rgba(0,150,255,0.6)) drop-shadow(0 0 30px rgba(0,200,255,0.4)); }
  .wire{stroke:var(--line);stroke-width:6;fill:none;opacity:.9}
  .wire.fuse{ stroke-dasharray:100; stroke-dashoffset:100; opacity:0; animation:fuseEffect 0.8s ease-out forwards }
  @keyframes fuseEffect{0%{stroke-dashoffset:100;opacity:0;filter:drop-shadow(0 0 12px rgba(0,255,0,.9))}50%{opacity:1;stroke:#3cff00}100%{stroke-dashoffset:0;opacity:1;stroke:var(--line)}}

  /* HEX WINDOWS */
  .hex{
    width:230px;height:230px;display:grid;place-items:center;background:#02060f;
    clip-path:polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%);
    border:4px solid #1e325e;box-shadow:inset 0 0 40px rgba(0, 0, 0, 0.7),0 0 20px rgba(64,200,255,.35);
    perspective:1000px;position:relative;transition:all .3s ease
  }
  .hex-border{ position:absolute; inset:12px; background:linear-gradient(135deg,#ffed4e,#ffd700,#ffaa00,#ffd700,#fff2a8);
    background-size:200% 200%; animation:shimmer 3s ease-in-out infinite;
    clip-path:polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%); z-index:-1; }
  @keyframes shimmer{0%,100%{background-position:0% 50%}50%{background-position:100% 50%}}

  .hex.winning{animation:winGlow 1.5s ease-in-out infinite; box-shadow:inset 5 0 400px rgba(0,210,255,.4),0 0 35px rgba(0,210,255,.8); border-color:#00d2ff}
  @keyframes winGlow{0%,100%{filter:brightness(1);transform:scale(1)}50%{filter:brightness(1.8);transform:scale(1.15)}}

  .slot{position:relative;width:100%;height:100%;display:grid;place-items:center;transform-style:preserve-3d;}
  .slot img{width:95%;height:95%;object-fit:contain;border-radius:10px;backface-visibility:hidden;transform: translateY(-5%);}

  /* VERTICAL FLIP */
  .flip{animation:flipY 220ms linear}
  @keyframes flipY{0%{transform:rotateY(0deg) translateY(-5%)}50%{transform:rotateY(90deg) translateY(-5%)}100%{transform:rotateY(0deg) translateY(-5%)}}





  /* ANTICIPATION ECHO */
  .echo{position:absolute;inset:-10px;pointer-events:none}
  .echo::before,.echo::after{
    content:"";position:absolute;inset:0;border-radius:12px;
    clip-path:polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%);
    box-shadow:0 0 0 3px rgba(0,210,255,.8);animation:echo 1s ease-out infinite;
  }
  .echo::after{animation-delay:.4s}
  @keyframes echo{0%{transform:scale(.9);opacity:1}100%{transform:scale(1.35);opacity:0}}

  /* TEASE RING */
  .tease-ring{
    position:absolute;inset:-16px;pointer-events:none;border-radius:14px;opacity:0;transition:opacity .2s ease;
    clip-path:polygon(50% 0%, 93.3% 25%, 93.3% 75%, 50% 100%, 6.7% 75%, 6.7% 25%);
    box-shadow:0 0 0 3px var(--tease),0 0 18px 6px rgba(77,243,255,.45), inset 0 0 22px rgba(77,243,255,.18);
    filter:drop-shadow(0 0 16px rgba(77,243,255,.75))
  }
  .teasing .tease-ring{opacity:1;animation:teasePulse .85s ease-in-out infinite}
  .teasing-strong .tease-ring{opacity:1;box-shadow:0 0 0 4px var(--tease-strong),0 0 26px 10px rgba(127,249,255,.65), inset 0 0 28px rgba(127,249,255,.28); animation:teasePulseStrong .55s ease-in-out infinite}
  @keyframes teasePulse{0%,100%{transform:scale(1);opacity:.85}50%{transform:scale(1.06);opacity:1}}
  @keyframes teasePulseStrong{0%,100%{transform:scale(1);opacity:.9}50%{transform:scale(1.09);opacity:1}}

  /* Border flash */
  .game.border-flash{animation:borderFlash 900ms ease}
  @keyframes borderFlash{
    0%{box-shadow:0 40px 90px rgba(0,0,0,.6) inset, 0 14px 40px rgba(0,0,0,.6), 0 0 0 0 rgba(73,185,255,.0)}
    20%{box-shadow:0 40px 90px rgba(0,0,0,.4) inset, 0 14px 40px rgba(0,0,0,.4), 0 0 32px 8px rgba(73,185,255,.9)}
    100%{box-shadow:0 40px 90px rgba(0,0,0,.6) inset, 0 14px 40px rgba(0,0,0,.6), 0 0 0 0 rgba(73,185,255,.0)}
  }

  /* CONTROLS (bottom UI) */
  .controls{
    position:absolute;left:0;right:0;bottom:0;height:180px;
    background:linear-gradient(180deg,#1a2241,#0d1635);
    display:flex;flex-direction:column;padding:0;
    border-top:3px solid #ffa500;
    box-shadow:0 -4px 20px rgba(0,0,0,.5)
  }
  
  /* INFO BAR */
  .info-bar{
    height:60px;background:linear-gradient(180deg,#2b3d6b,#1a2857);
    display:flex;align-items:center;justify-content:space-between;
    padding:0 30px;border-bottom:2px solid #142652;
    box-shadow:0 2px 10px rgba(0,0,0,.3)
  }
  .info-item{display:flex;align-items:center;gap:12px;font-weight:900;font-size:20px;text-shadow:0 2px 4px rgba(0,0,0,.5)}
  .info-label{color:#ffa500;font-size:14px;text-transform:uppercase;letter-spacing:1px;display:flex;align-items:center;gap:6px}
  .info-value{
    background:linear-gradient(180deg,#0a0f1f,#050810);
    border:2px solid #ffa500;border-radius:8px;padding:8px 20px;min-width:120px;text-align:center;
    color:#ffffff;font-size:24px;font-weight:900;
    box-shadow:inset 0 2px 8px rgba(0,0,0,.5),0 1px 0 rgba(255,165,0,.2)
  }
  .info-value.win{border-color:#2ecc71;color:#2ecc71;background:linear-gradient(180deg,#0a1f0f,#051008)}
  .info-value.win.counting{animation:winPulse .9s ease-in-out infinite;box-shadow:inset 0 2px 8px rgba(0,0,0,.5),0 0 20px rgba(46,204,113,.4)}
  @keyframes winPulse{0%,100%{border-color:#2ecc71}50%{border-color:#4eff8c;filter:brightness(1.2)}}
  
  /* BET + SPIN */
  .bet-spin-section{flex:1;display:flex;align-items:center;justify-content:center;gap:20px;padding:20px;background:radial-gradient(ellipse at center,rgba(255,165,0,.05),transparent)}
  .bet-buttons{
    display:flex;gap:8px;background:linear-gradient(180deg,#0a1430,#050a1a);
    padding:12px;border-radius:12px;border:2px solid #ffa500;
    box-shadow:inset 0 2px 10px rgba(0,0,0,.5),0 4px 15px rgba(0,0,0,.3)
  }
  .bet-btn{
    background:linear-gradient(180deg,#1a2857,#0d1635);color:#ffffff;border:2px solid #2a4280;border-radius:8px;
    padding:0;width:90px;height:90px;font-weight:900;font-size:24px;cursor:pointer;
    transition:all .2s;display:flex;align-items:center;justify-content:center;text-shadow:0 2px 4px rgba(0,0,0,.5)
  }
  .bet-btn:hover{transform:translateY(-2px);filter:brightness(1.1)}
  .bet-btn.active{background:linear-gradient(180deg,#00a8ff,#0078c1);border-color:#00d2ff;animation:betActive 2s ease-in-out infinite}
  @keyframes betActive{0%,100%{box-shadow:0 0 15px rgba(0,210,255,.4)}50%{box-shadow:0 0 25px rgba(0,210,255,.7)}}
  .bet-btn[disabled]{opacity:.5;cursor:not-allowed;filter:grayscale(1)}
  
  .spin-btn{
    width:140px;height:140px;border-radius:50%;position:relative;background:radial-gradient(circle at 30% 30%,#0099ff,#0066cc);
    border:4px solid #ffa500;cursor:pointer;box-shadow:0 8px 25px rgba(0,0,0,.5),inset 0 -4px 10px rgba(0,0,0,.3);
    display:flex;align-items:center;justify-content:center;font-weight:900;font-size:36px;color:#ffffff;text-shadow:0 3px 8px rgba(0,0,0,.5);
    transition:all .2s;animation:spinReady 3s ease-in-out infinite
  }
  @keyframes spinReady{0%,100%{box-shadow:0 8px 25px rgba(0,0,0,.5)}50%{box-shadow:0 8px 25px rgba(0,0,0,.5),0 0 30px 5px rgba(255,165,0,.4)}}
  .spin-btn:hover{transform:scale(1.05);filter:brightness(1.2)}
  .spin-btn:active{transform:scale(0.98)}
  .spin-btn[disabled]{opacity:.5;cursor:not-allowed;animation:none}
  
  .side-buttons{display:flex;flex-direction:column;gap:10px}
  .side-btn{
    background:linear-gradient(180deg,#2a3d6b,#1a2857);color:#ffa500;border:2px solid #ffa500;border-radius:8px;
    padding:12px 20px;font-weight:800;font-size:14px;cursor:pointer;text-transform:uppercase;letter-spacing:1px;transition:all .2s;min-width:120px
  }
  .side-btn:hover{transform:translateY(-1px);filter:brightness(1.15)}
  .side-btn[disabled]{opacity:.5;cursor:not-allowed}

  /* Free spin counters */
  .fs-counter { position:absolute; z-index:8; }
  .fs-image { background:none; border:none; padding:0; margin:0; pointer-events:none; }
  .fs-image img { display:block; width:auto; height:150px; object-fit:contain; }
  .fs-text {
    background: linear-gradient(135deg,#0a1430,#1a2857); border:2px solid #ffa500; border-radius:8px; color:#fff;
    padding:8px 14px; font-size:32px; font-weight:900; text-shadow:0 0 8px rgba(0,0,0,.6);
    box-shadow: inset 0 2px 6px rgba(0,0,0,.5), 0 0 12px rgba(255,165,0,.4); pointer-events:none;
  }
  .fs-left{bottom:20px;left:50px}
  .fs-right{bottom:20px;right:20px}

  /* Flip container for the FS counter */
.fs-flip{
  display:grid;
  place-items:center;
  height:150px;          /* matches your existing counter height */
  transform-style:preserve-3d;
}

/* Both faces occupy the same grid cell */
.fs-flip > img{
  grid-area:1/1;
  width:auto;
  height:100%;
  object-fit:contain;
  backface-visibility:hidden;
}

/* Back face is rotated so it faces the viewer when the container reaches 180° */
.fs-flip > img.back{ transform: rotateY(180deg); }

/* One-off HALF flip: old image 0→90→180, then stop. */
@keyframes fsHalfFlip {
  from { transform: rotateY(0deg); }
  to   { transform: rotateY(180deg); }
}

/* Keep the end state at 180° so the back face (new image) is visible */
.fs-flip.animating {
  animation: fsHalfFlip 0.6s ease-in-out forwards; /* adjust speed as desired */
}


  /* BANNERS */
  .banner{ position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    background:#0c1632; border:2px solid #2b4b93; border-radius:14px; padding:20px 24px; text-align:center;
    display:none; z-index:30; font-weight:900; font-size:22px }
  .banner.show{display:block}
  .pulse{animation:pulse 1.1s infinite}
  @keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(0,210,255,.35)}50%{box-shadow:0 0 28px 0 rgba(0,210,255,.9)}}
  
  /* Big win display */
  .big-win-display{position:absolute;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0, 0, 0, 0.65);z-index:100;flex-direction:column}
  .big-win-display.show{display:flex}
  .big-win-text{font-size:132px;font-weight:900;color:#ffd700;margin-bottom:20px;text-shadow:0 0 20px rgba(255,215,0,.8)}
  .big-win-amount{
    font-size:100px;font-weight:900;background:linear-gradient(45deg,#cacaca,#ffed4e);-webkit-background-clip:text;background-clip:text;color:transparent;
    text-shadow:0 0 30px rgba(255,255,255,.6);animation:bigWinPulse 1s ease-in-out infinite
  }
  @keyframes bigWinPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}

  /* PAYTABLE */
  .overlay{position:absolute;inset:0;background:rgba(5,7,12,.9);display:none;z-index:40}
  .overlay.show{display:flex;align-items:center;justify-content:center}
  .card{background:#0d183a;border:1px solid #2d4ea0;border-radius:14px;max-width:860px;width:92%;padding:18px}
  .card h2{margin:0 0 10px 0}
  .pt{display:grid;grid-template-columns:1fr auto;gap:10px}
  .pt div{padding:8px 12px;background:#0b1430;border:1px solid #203a7a;border-radius:10px;font-weight:800}

  .wordmark{position:absolute;left:50%;bottom:1px;transform:translateX(-50%);font-size:64px;font-weight:900;letter-spacing:2px;opacity:.22;text-shadow:0 2px 0 rgba(255,255,255,.08),0 -2px 0 rgba(0,0,0,.6)}
  #startBonus { display:block; margin: 10px auto 0; }
  .jackpot-celebration { display: none !important; }

</style>




</style>
</head>
<body>
<div class="game" id="game">
  <!-- HEADER -->
<div class="header">
    <img src="assets/contact_Topper_1280x200.jpg" alt="Top Screen">
</div>

  <!-- JACKPOTS -->
<div class="jackpots">
    <video autoplay loop muted playsinline>
        <source src="assets/progressives.webm" type="video/webm">
    </video>
</div>


  <!-- PLAYFIELD -->
  <div class="playfield">
    <!-- PRECOG VIDEO OVERLAY (cover playfield only) -->
    <div class="precog-overlay" id="precogOverlay">
      <video id="precogVideo" preload="auto" playsinline></video>
    </div>

    <!-- JACKPOT OVERLAY (video behind the existing rolling counter) -->
<div id="jackpotOverlay" class="overlay-hidden">
  <video id="jackpotVideo"
         playsinline
         preload="metadata"></video>

  <!-- If your rolling count-up already renders elsewhere, you can ignore this.
       Otherwise, you can mount or temporarily move your existing jackpot
       count-up node into this container for stacking. -->
  <div id="jackpotCounterMount"></div>
</div>


    <div class="playfield-inner" id="playfieldInner">
      <!-- BASE GAME SIDE -->
      <div class="side-base">
        <svg class="wires" viewBox="0 0 1280 580" preserveAspectRatio="none">
            <path class="wire" d="M0 140 L1020 140"/>
            <path class="wire" d="M1020 140 L640 380"/>
            <path class="wire" d="M640 380 L482 380"/>
            <path class="wire" d="M485 380 L485 500"/>
        </svg>
        <div class="wordmark"><img src="assets/contact_tt.png"></div>
        <div class="nodes">
<div class="node r1">
  <div class="hex-border"></div>
  <div class="hex" id="hex0">
    <div class="slot"><img id="img0" src="./assets/wild.png" alt="r1"></div>
  </div>
</div>
            
          <div class="node r2">
              <div class="hex-border"></div>
            <div class="hex" id="hex1">
              <div class="slot"><img id="img1" src="./assets/wild.png" alt="r2"></div>
            </div>
          </div>
          <div class="node r3">
              <div class="hex-border"></div>
            <div class="hex" id="hex2">
              <span class="tease-ring"></span>
              <div class="slot">
                <span class="echo" id="echo" style="display:none"></span>
                <img id="img2" src="./assets/wild.png" alt="r3">
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- BONUS GAME SIDE -->
      <div class="side-bonus">
        <svg class="wires" viewBox="0 0 1280 580" preserveAspectRatio="none">
            <path class="wire" id="wire1" d="M0 140 L1020 140"/>
            <path class="wire" id="wire2" d="M1020 140 L640 380"/>
            <path class="wire" id="wire3" d="M640 380 L482 380"/>
            <path class="wire" id="wire4" d="M485 380 L485 500"/>
        </svg>
        <div class="wordmark"><img src="assets/contact_tt.png"></div>
        <div class="nodes">
          <div class="node r1">
                          <div class="hex-border"></div>
            <div class="hex" id="bonusHex0"><div class="slot"><img id="bonusImg0" src="./assets/fg_blank.png" alt="b1"></div></div>
          </div>
          <div class="node r2">              <div class="hex-border"></div>

            <div class="hex" id="bonusHex1"><div class="slot"><img id="bonusImg1" src="./assets/fg_blank.png" alt="b2"></div></div>
          </div>
          <div class="node r3">
                          <div class="hex-border"></div>

            <div class="hex" id="bonusHex2"><div class="slot"><img id="bonusImg2" src="./assets/fg_blank.png" alt="b3"></div></div>
          </div>
        </div>
        <!-- Update the existing free spin counters to use images -->
<!-- Left free-spin counter (image) -->
<div class="fs-counter fs-left fs-image" id="fsLeft" style="display:none">
  <div class="fs-flip" id="fsFlip">
    <!-- FRONT: starts as current image -->
    <img class="face front" id="fsSpinImage" src="./assets/FS_10.png" alt="">
    <!-- BACK: preloaded with the NEXT image right before the flip -->
    <img class="face back" id="fsSpinImageBack" src="./assets/FS_10.png" alt="">
  </div>
</div>


<!-- Win Meter (text) -->
<div class="fs-counter fs-right fs-text" id="fsRight" style="display:none">
  Win: $0.00
</div>

</div>
    </div>
  </div>

  <!-- BOTTOM UI -->
  <div class="controls">
    <div class="info-bar">
      <div class="info-item"><span class="info-label">1 CREDIT =</span><span class="info-value">1¢</span></div>
      <div class="info-item"><span class="info-label">CREDITS</span><span class="info-value" id="credits">10000</span></div>
      <div class="info-item"><span class="info-label">BET</span><span class="info-value" id="bet">50</span></div>
      <div class="info-item"><span class="info-label">WIN</span><span class="info-value win" id="win">0</span></div>
    </div>
    <div class="bet-spin-section">
      <div class="bet-buttons">
        <button class="bet-btn active" data-bet="50">50</button>
        <button class="bet-btn" data-bet="100">100</button>
        <button class="bet-btn" data-bet="150">150</button>
        <button class="bet-btn" data-bet="250">250</button>
        <button class="bet-btn" data-bet="500">500</button>
      </div>
      <button class="spin-btn" id="spin">SPIN</button>
      <div class="side-buttons">
        <button class="side-btn" id="paytableBtn">Paytable</button>
        <button class="side-btn" id="sound">Sound</button>
      </div>
    </div>
  </div>

  <!-- Big Win Display -->
  <div class="big-win-display" id="bigWinDisplay">
    <div class="big-win-text">YOU WON</div>
    <div class="big-win-amount" id="bigWinAmount">0</div>
  </div>
  <!-- Add these elements inside the .game div, after the existing big-win-display -->


<!-- Bonus Spin Win Display -->
<div class="bonus-win-display" id="bonusWinDisplay">
  <div class="bonus-win-label">WINNER!</div>
  <div class="bonus-win-amount" id="bonusWinAmount">$0</div>
</div>



  <!-- PAYTABLE -->
  <div class="overlay" id="paytable">
    <div class="card">
      <h2>Paytable (Base Game)</h2>
      <div class="pt">
        <div>3 WILDs</div><div>×100 Bet</div>
        <div>3 H1 Symbols</div><div>×40 Bet</div>
        <div>3 H2 Symbols</div><div>×30 Bet</div>
        <div>3 H3 Symbols</div><div>×20 Bet</div>
        <div>3 M1 Symbols</div><div>×12 Bet</div>
        <div>3 M2 Symbols</div><div>×10 Bet</div>
        <div>3 M3 Symbols</div><div>×8 Bet</div>
        <div>3 L1 Symbols</div><div>×5 Bet</div>
        <div>3 L2 Symbols</div><div>×3 Bet</div>
        <div>3-2-1 anywhere</div><div>Triggers Contact Bonus</div>
      </div>
      <h2 style="margin-top:14px">Contact Bonus</h2>
      <div class="pt">
        <div>10 Free Spins</div><div>Cash on Reels</div>
        <div>All 3 positions must have cash/jackpot to win</div><div>—</div>
        <div>Cash Values</div><div>1×,2×,5×,10×,15×,25×,75×,100× Bet</div>
        <div>2× Multiplier</div><div>Multiplies total spin win</div>
        <div>Mini Jackpot</div><div>$10</div>
        <div>Minor Jackpot</div><div>$50</div>
        <div>Major Jackpot</div><div>$1,000</div>
        <div>Grand Jackpot</div><div>$5,000</div>
      </div>
      <div style="text-align:center;margin-top:12px"><button class="side-btn" id="closePT">Close</button></div>
    </div>
  </div>

  <!-- Bonus intro -->
  <div class="banner" id="bonusIntro">
    <div class="title">CONTACT BONUS</div>
    <div>Press to start bonus</div>
    <div style="margin-top:10px"><button class="spin-btn" style="width:300px;height:125px;font-size:48px" id="startBonus">START</button></div>
  </div>
</div>

<script>
/* ============================================================
   321 CONTACT — Enhanced v7 (Fixed)
   ============================================================ */

const DEBUG = { forceSymbolsOnce:null, forceBonusWin:null, forcePrecog:false };
window.forceBonusOnce = () => { DEBUG.forceSymbolsOnce = [SYM.BONUS3, SYM.BONUS2, SYM.BONUS1]; };
window.forceNearMissOnce = () => { DEBUG.forceSymbolsOnce = [SYM.BONUS3, SYM.BONUS2, SYM.H1]; };
window.forceJackpot = () => { DEBUG.forceBonusWin = 'grand'; };
window.forcePrecog = () => { DEBUG.forcePrecog = true; };

const SYM = { WILD:'wild.png', BLANK:'Blank.png', BONUS3:'3.png', BONUS2:'2.png', BONUS1:'1.png', H1:'h1.png', H2:'h2.png', H3:'h3.png', M1:'m1.png', M2:'m2.png', M3:'m3.png', L1:'l1.png', L2:'l2.png' };
const CASH_MULTIPLIERS = [1,2,5,10,15,25,75,100];
// Weighted odds for cash tiles (bigger = rarer)
// Tune these to taste; the ratios matter, not the absolute numbers.
const CASH_WEIGHTS = {
  1: 40,
  2: 28,
  5: 16,
  10: 38,
  15: 5,
  25: 2.5,
  75: 1.7,
  100: 1.3
};

function pickCashMultiplierWeighted() {
  const entries = Object.entries(CASH_WEIGHTS).map(([m, w]) => [Number(m), Number(w)]);
  const total = entries.reduce((s, [, w]) => s + w, 0);
  let roll = Math.random() * total;
  for (const [mult, w] of entries) {
    roll -= w;
    if (roll <= 0) return mult;
  }
  return entries[0][0]; // fallback
}


function getCashFilename(mult, betAmount){ return `fg_${mult * betAmount}.png`; }
const PAYS_3OAK = { [SYM.WILD]:100, [SYM.H1]:40, [SYM.H2]:30, [SYM.H3]:20, [SYM.M1]:12, [SYM.M2]:10, [SYM.M3]:8, [SYM.L1]:5, [SYM.L2]:3 };
const JACKPOT_VALUES = { mini:1000, minor:5000, major:100000, grand:500000 };
function pulsePlayfield() {
  playfieldInner.classList.remove('bonus-pulse');
  // force reflow so animation can retrigger
  void playfieldInner.offsetWidth;
  playfieldInner.classList.add('bonus-pulse');
}
// Force a base-game line hit by number key (1–9)
const LINE_TEST_MAP = {
  '1': SYM.L2,
  '2': SYM.L1,
  '3': SYM.M3,
  '4': SYM.M2,
  '5': SYM.M1,
  '6': SYM.H3,
  '7': SYM.H2,
  '8': SYM.H1,
  '9': SYM.WILD
};

const SFX = {
  base3:new Audio('./audio/Contact_3.mp3'),
  base2:new Audio('./audio/Contact_2.mp3'),
  base2Ant:new Audio('./audio/Contact_2_anticpation.mp3'),
  base1Contact:new Audio('./audio/Contact_1Contact.mp3'),
  fgTrans:new Audio('./audio/Contact_FG_Trans1.mp3'),
  fgWaitIntro:new Audio('./audio/Contact_FG_waitIntro.mp3'),
  fgWaitLoop:new Audio('./audio/Contact_FG_waitLoop.mp3'),
  fgLoop:new Audio('./audio/Contact_FG_Loop.mp3'),
  fgOutro:new Audio('./audio/Contact_FG_Outro.mp3'),
  fgBigWinLoop:new Audio('./audio/Contact_FG_BigWin_Loop.mp3'), // ADD THIS LINE
  reelSpinMusic:new Audio('./audio/reel_spin_music.mp3'),
  reelStop1:new Audio('./audio/reelstop1.mp3'),
  winSmall:new Audio('./audio/Rack_2small.mp3'),
  winSmall2:new Audio('./audio/Rack_4small2.mp3'),
  winMed:new Audio('./audio/Rack_5med.mp3'),
  winLarge:new Audio('./audio/Rack_7large.mp3'),
  winBig:new Audio('./audio/Rack_9extralarge.mp3')
};
// Wait screen behavior: intro does NOT loop; the loop does.
SFX.fgWaitIntro.loop = false;
SFX.fgWaitLoop.loop  = true;

// Existing loops
SFX.fgLoop.loop = true;
SFX.reelSpinMusic.loop = true;
SFX.fgBigWinLoop.loop = true;

// Preload + prime for tighter handoff
SFX.fgWaitIntro.preload = 'auto';
SFX.fgWaitLoop.preload  = 'auto';

let audioEnabled = true;
const soundBtn = document.getElementById('sound');
soundBtn.textContent = 'Sound On';

soundBtn.addEventListener('click', async () => {
  if (!audioEnabled) {
    // Turn ON audio
try {
  await SFX.winSmall.play(); SFX.winSmall.pause(); SFX.winSmall.currentTime = 0;
} catch {}
// Prime the wait LOOP so it's decoded before we need it
try {
  await SFX.fgWaitLoop.play(); 
  SFX.fgWaitLoop.pause(); 
  SFX.fgWaitLoop.currentTime = 0;
} catch {}

audioEnabled = true;
soundBtn.textContent = 'Sound On';
  } else {
    // Turn OFF audio
    audioEnabled = false;
    soundBtn.textContent = 'Sound Off';
    try { 
      Object.values(SFX).forEach(a => { a.pause(); a.currentTime = 0; }); 
    } catch {}
  }
});

function safePlay(a,{loop=false,from=0,restart=true}={}){
  if(!audioEnabled||!a) return;
  try{
    a.loop=!!loop;
    if(restart){
      if(!a.paused) a.pause();
      a.currentTime = from || 0;
    }
    if(a.paused) a.play().catch(()=>{});
  }catch{}
}
function safeStop(a){ if(!a)return; try{ a.pause(); a.currentTime=0; }catch{} }
function fadeOutAudio(a,d=500){ if(!a||a.paused)return; const v=a.volume, n=20, dt=d/n; let i=0; const id=setInterval(()=>{ i++; a.volume=v*(1-i/n); if(i>=n){clearInterval(id); a.pause(); a.currentTime=0; a.volume=v;} }, dt); }
function stopAllWinTracks(){ [SFX.winSmall,SFX.winSmall2,SFX.winMed,SFX.winLarge,SFX.winBig].forEach(safeStop); }

/******** COUNT-UP ENGINE (re-added) ********/
function countUpWin(amount, { targetEl = null, onDone = null, muteAudio = false } = {}) {
  if (!amount || amount <= 0) {
    state.win = 0; updateMeters();
    if (targetEl) targetEl.textContent = '0';
    if (onDone) onDone();
    return;
  }

  // choose duration & sfx tier
  let duration = 4000; // default 4s
  let track = SFX.winSmall;
  if (amount <= 100)      { duration = 4000;  track = SFX.winSmall; }
  else if (amount <= 300) { duration = 6000;  track = SFX.winSmall2; }
  else if (amount <= 1000){ duration = 11000; track = SFX.winMed; }
  else if (amount <= 5000){ duration = 36000; track = SFX.winLarge; }
  else                    { duration = 184000; track = SFX.winBig; }

  if (!muteAudio) { stopAllWinTracks(); safePlay(track); }

  state.countingUp = true;
  state.skipRequested = false;
  winEl.classList.add('counting');

  const start = performance.now();
  state.win = 0;
  updateMeters();

  function frame(now) {
    if (state.skipRequested) {
      state.skipRequested = false;
      state.countingUp = false;
      winEl.classList.remove('counting');
      stopAllWinTracks();
      state.win = amount;
      state.credits += amount;
      updateMeters();
      if (targetEl) targetEl.textContent = amount;
      if (onDone) onDone();
      return;
    }
    const p = Math.min(1, (now - start) / duration);
    const current = Math.floor(amount * p);
    state.win = current;
    updateMeters();
    if (targetEl) targetEl.textContent = current;
    if (p < 1) {
      requestAnimationFrame(frame);
    } else {
      state.countingUp = false;
      winEl.classList.remove('counting');
      stopAllWinTracks();
      state.win = amount;
      state.credits += amount;
      updateMeters();
      if (targetEl) targetEl.textContent = amount;
      if (onDone) onDone();
    }
  }
  requestAnimationFrame(frame);
}


const BET_STEPS=[50,100,150,250,500];
const state={ credits:10000, betIndex:0, spinning:false, inBonus:false, win:0, countingUp:false, skipRequested:false, bonusSpins:0, bonusTotal:0, precogActive:false };
const creditsEl=document.getElementById('credits'); const betEl=document.getElementById('bet'); const winEl=document.getElementById('win');
const spinBtn=document.getElementById('spin'); const paytable=document.getElementById('paytable'); const closePTBtn=document.getElementById('closePT'); const paytableBtn=document.getElementById('paytableBtn');
const bonusIntro=document.getElementById('bonusIntro'); const startBonusBtn=document.getElementById('startBonus'); const playfieldInner=document.getElementById('playfieldInner');
const fsLeft=document.getElementById('fsLeft'); const fsRight=document.getElementById('fsRight'); const bigWinDisplay=document.getElementById('bigWinDisplay'); const bigWinAmount=document.getElementById('bigWinAmount');
const gameRoot=document.getElementById('game'); const precogOverlay=document.getElementById('precogOverlay'); const precogVideo=document.getElementById('precogVideo'); if(precogVideo) precogVideo.src='./assets/Contact_Precog_Video.webm';
const imgs=[document.getElementById('img0'),document.getElementById('img1'),document.getElementById('img2')];
const hexes=[document.getElementById('hex0'),document.getElementById('hex1'),document.getElementById('hex2')];
const echoEl=document.getElementById('echo'); const r3Hex=document.getElementById('hex2');
const bonusImgs=[document.getElementById('bonusImg0'),document.getElementById('bonusImg1'),document.getElementById('bonusImg2')];
const wire1=document.getElementById('wire1'), wire2=document.getElementById('wire2'), wire3=document.getElementById('wire3'), wire4=document.getElementById('wire4');
const bonusWinDisplay = document.getElementById('bonusWinDisplay');
const bonusWinAmount = document.getElementById('bonusWinAmount');
const fsSpinImage = document.getElementById('fsSpinImage');
const fsFlip = document.getElementById('fsFlip');
const fsSpinImageBack = document.getElementById('fsSpinImageBack');
let lastFsCount = null;
// guard to prevent double-start of the wait loop
let isWaitLoopPlaying = false;

const FS_SPIN_MS = 1200; // keep in sync with CSS animation duration

const bonusHexes = [
  document.getElementById('bonusHex0'),
  document.getElementById('bonusHex1'),
  document.getElementById('bonusHex2'),
];

/******** HELPERS ADDED (meters, bet, UI) ********/
// --- JACKPOT VIDEO HELPERS (final) ---

// Normalize accepted tiers (input can be any case)
const JACKPOT_TIERS = new Set(["Mini", "Minor", "Major", "Grand"]);

function normalizeTier(tier) {
  const t = String(tier || "").trim().toLowerCase();
  if (t === "mini")  return "Mini";
  if (t === "minor") return "Minor";
  if (t === "major") return "Major";
  if (t === "grand") return "Grand";
  console.warn("Unknown jackpot tier:", tier, "- defaulting to Major");
  return "Major";
}

/**
 * Build filename by convention within /assets:
 * assets/Contact_Jackpot_<Tier>.webm
 * assets/Contact_Jackpot_<Tier>2x.webm
 * assets/Contact_Jackpot_<Tier>4x.webm
 */
function getJackpotVideoFilename(tier, multiplier = 1) {
  const safeTier = normalizeTier(tier);
  const multSuffix = (multiplier && Number(multiplier) > 1) ? `${multiplier}x` : "";
  return `assets/Contact_Jackpot_${safeTier}${multSuffix}.webm`;
}

/**
 * Play a jackpot video behind the rolling counter.
 * - tier: "Mini" | "Minor" | "Major" | "Grand" (any case ok)
 * - multiplier: 1 | 2 | 4
 * - mountCounterEl: existing element that shows the rolling count (will be temporarily re-parented)
 * - timeoutMs: hard failsafe
 */
function playJackpotVideo({ tier, multiplier = 1, mountCounterEl = null, timeoutMs = 16000 } = {}) {
  return new Promise((resolve) => {
    const overlay = document.getElementById("jackpotOverlay");
    const video   = document.getElementById("jackpotVideo");
    const counterMount = document.getElementById("jackpotCounterMount");

    // Choose the asset
    const src = getJackpotVideoFilename(tier, multiplier);
    console.log("Jackpot video src =", src);

    // Show overlay
    overlay.classList.remove("overlay-hidden");
    overlay.classList.add("overlay-show");

    // Temporarily re-parent the rolling counter (optional)
    let originalParent = null;
    let placeholder = null;
    if (mountCounterEl && counterMount && mountCounterEl.parentElement !== counterMount) {
      originalParent = mountCounterEl.parentElement;
      placeholder = document.createComment("jackpotCounterPlaceholder");
      originalParent && originalParent.replaceChild(placeholder, mountCounterEl);
      counterMount.appendChild(mountCounterEl);
    }

    // Cleanup
    let done = false;
    const finish = () => {
      if (done) return;
      done = true;

      // restore counter
      if (mountCounterEl && originalParent && placeholder && placeholder.parentElement) {
        placeholder.parentElement.replaceChild(mountCounterEl, placeholder);
      }

      overlay.classList.remove("overlay-show");
      overlay.classList.add("overlay-hidden");

      // reset video
      video.removeAttribute("src");
      video.load();

      resolve();
    };

    const kill = setTimeout(finish, timeoutMs);

    video.onended = () => { clearTimeout(kill); finish(); };
    video.onerror = () => {
      console.warn("Jackpot video failed to load:", src);S
      clearTimeout(kill);
      finish();
    };

    // IMPORTANT: ensure the tag itself is not hardcoded with `muted` in HTML.
    // We’ll try with audio first.
    video.removeAttribute("muted");
    video.setAttribute("playsinline", "");
    video.loop = false;
    video.src = src;
    video.load();

    // Try with audio; if blocked, retry muted (policy-safe)
    const tryPlay = () => video.play().catch(err => {
      console.warn("Autoplay/playback issue:", err, "— retrying muted");
      video.muted = true;
      return video.play().catch(e2 => {
        console.warn("Muted playback also failed:", e2);
        throw e2;
      });
    });

    tryPlay().catch(() => {
      // Optional: start fallback SFX here if you want audio when video can’t play
      // safePlay(SFX.fgBigWinLoop, { loop: true });
    });
  });
}

/******** BASE GAME WEIGHTS + PICKER ********/
const BASE_WEIGHTS = {
  R1: {
    [SYM.BONUS3]: 20,
    [SYM.WILD]: 10,
    [SYM.H1]: 6, [SYM.H2]: 6, [SYM.H3]: 6,
    [SYM.M1]: 8, [SYM.M2]: 8, [SYM.M3]: 8,
    [SYM.L1]: 10, [SYM.L2]: 10,
  },
  R2: {
    [SYM.BONUS2]: 20,
    [SYM.WILD]: 15,
    [SYM.H1]: 6, [SYM.H2]: 6, [SYM.H3]: 6,
    [SYM.M1]: 8, [SYM.M2]: 8, [SYM.M3]: 8,
    [SYM.L1]: 10, [SYM.L2]: 10,
  },
  R3: {
    [SYM.BONUS1]: 19,
    [SYM.WILD]: 5,
    [SYM.H1]: 6, [SYM.H2]: 6, [SYM.H3]: 6,
    [SYM.M1]: 8, [SYM.M2]: 8, [SYM.M3]: 8,
    [SYM.L1]: 10, [SYM.L2]: 10,
  }
};

/******** FREE GAMES SELECTION ********/
function getJackpotTypeForBet(){
  const b = bet();
  const mults = {
    50:  { mini:1.00, minor:1.00, major:1.00, grand:1.00 },
    100: { mini:1.10, minor:1.07, major:1.05, grand:1.03 },
    150: { mini:1.20, minor:1.12, major:1.08, grand:1.05 },
    250: { mini:1.35, minor:1.20, major:1.12, grand:1.07 },
    500: { mini:1.50, minor:1.30, major:1.18, grand:1.10 },
  }[b] || { mini:1, minor:1, major:1, grand:1 };

  const base = { mini:3.0, minor:1.2, major:0.15, grand:0.03 };
  const weighted = Object.fromEntries(Object.entries(base).map(([k,v]) => [k, v * (mults[k] || 1)]));
  const total = Object.values(weighted).reduce((a,c)=>a+c,0);
  let roll = Math.random() * total;
  for (const [name, w] of Object.entries(weighted)) {
    if ((roll -= w) <= 0) return name;
  }
  return 'mini';
}

function getBonusResult(){
  // Category shares kept stable; only jackpot *type* shifts by bet
  const JACKPOT_SHARE = 0.10; // any jackpot
  const CASH_SHARE    = 0.40;
  const MULTI_SHARE   = 0.10;
  const BLANK_SHARE   = 1 - JACKPOT_SHARE - CASH_SHARE - MULTI_SHARE;

  const r = Math.random();
  if (r < BLANK_SHARE) {
    return { type: 'blank', file: 'fg_blank.png' };
  } else if (r < BLANK_SHARE + CASH_SHARE) {
      const mult = pickCashMultiplierWeighted();
    return { type: 'cash', mult, file: getCashFilename(mult, bet()) };
  } else if (r < BLANK_SHARE + CASH_SHARE + MULTI_SHARE) {
    return { type: 'multi', mult: 2, file: 'fg_2x.png' };
  } else {
    const name = getJackpotTypeForBet();
    return { type: 'jackpot', name, file: `fg_${name}.png` };
  }
}


function weightedPick(weights) {
  const entries = Object.entries(weights);
  const total = entries.reduce((s, [, w]) => s + w, 0);
  let roll = Math.random() * total;
  for (const [sym, w] of entries) {
    roll -= w;
    if (roll <= 0) return sym;
  }
  return entries[entries.length - 1][0];
}

function bet(){ return BET_STEPS[state.betIndex]; }
function toCurrency(cents){ return (cents/100).toLocaleString(undefined,{style:'currency',currency:'USD',minimumFractionDigits:2,maximumFractionDigits:2}); }
function updateMeters(){
  creditsEl.textContent = state.credits;
  betEl.textContent = bet();
  winEl.textContent = state.win;
  winEl.classList.toggle('win', state.win > 0);
}
function setUI(enabled){
  // Only disable spin button if we're not counting up (so skip still works)
  if (!state.countingUp) {
    // spinBtn.disabled = !enabled;
  }
  document.querySelectorAll('.bet-btn').forEach(b => b.disabled = !enabled);
  paytableBtn.disabled = !enabled;
}
document.querySelectorAll('.bet-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    if (state.spinning || state.inBonus) return;
    const betValue = parseInt(btn.dataset.bet);
    state.betIndex = BET_STEPS.indexOf(betValue);
    updateBetButtons();
    updateMeters();
  });
});
function updateBetButtons(){
  document.querySelectorAll('.bet-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.bet) === bet());
  });
}

let spinTimers=[null,null,null];
function startReel(r,isBonus=false){
  const pool=isBonus? ['fg_blank.png','fg_2x.png','fg_mini.png','fg_minor.png','fg_major.png','fg_grand.png'].concat(CASH_MULTIPLIERS.map(m=>getCashFilename(m, bet()))) : Object.keys(BASE_WEIGHTS[`R${r+1}`]);
  const imgEls=isBonus?bonusImgs:imgs; let idx=Math.floor(Math.random()*pool.length);
  spinTimers[r]=setInterval(()=>{ const img=imgEls[r]; img.classList.remove('flip'); void img.offsetWidth; img.classList.add('flip'); idx=(idx+1)%pool.length; img.src='./assets/'+pool[idx]; },70);
}
function stopReel(r,finalFile,isBonus=false){
  clearInterval(spinTimers[r]); spinTimers[r]=null;
  const imgEls=isBonus?bonusImgs:imgs; const img=imgEls[r];
  img.classList.remove('flip'); img.src='./assets/'+finalFile;
  if(!state.precogActive) safePlay(SFX.reelStop1);
}

function runPrecogSequence(result){
  state.precogActive=true; gameRoot.classList.add('precog-gaffe'); setTimeout(()=>gameRoot.classList.remove('precog-gaffe'),650); fadeOutAudio(SFX.reelSpinMusic,400);
  precogOverlay.classList.add('show'); try{precogVideo.currentTime=0; precogVideo.play().catch(()=>{});}catch{}
  startReel(0); startReel(1); startReel(2);
  setTimeout(()=>{ stopReel(0, result[0]); },10000);
  setTimeout(()=>{ stopReel(1, result[1]); },10700);
  setTimeout(()=>{ stopReel(2, result[2]); setTimeout(()=>{ precogOverlay.classList.remove('show'); try{precogVideo.pause();}catch{} state.precogActive=false; gameRoot.classList.add('border-flash'); setTimeout(()=>gameRoot.classList.remove('border-flash'),900); if (!state.precogActive) /* stinger suppressed during PRECOG */ enterBonus(); },100); },11400);
}

function handleSpinClick(){ 
    if(state.countingUp){ 
        state.skipRequested=true; 
        return; 
    } 
  if(state.inBonus) return; 
  if(!state.spinning) spin(); 
}
function spin(){
  if(state.spinning||state.inBonus) return;
  const cost=bet(); if(state.credits<cost){ flash('Insufficient Credits'); return; }
  hexes.forEach(h=>h.classList.remove('winning')); echoEl.style.display='none'; r3Hex.classList.remove('teasing','teasing-strong');
  state.credits-=cost; state.win=0; updateMeters(); state.spinning=true; setUI(false);
  let result;
  if(DEBUG.forceSymbolsOnce){ result=DEBUG.forceSymbolsOnce.slice(); DEBUG.forceSymbolsOnce=null; }
  else{ result=[weightedPick(BASE_WEIGHTS.R1), weightedPick(BASE_WEIGHTS.R2), weightedPick(BASE_WEIGHTS.R3)]; }
  const isBonusSpin=(result[0]===SYM.BONUS3 && result[1]===SYM.BONUS2 && result[2]===SYM.BONUS1);
  const shouldPrecog=isBonusSpin && (DEBUG.forcePrecog || Math.random()<0.40);
  if(shouldPrecog){ DEBUG.forcePrecog=false; runPrecogSequence(result); return; }
  safePlay(SFX.reelSpinMusic,{loop:true});
  startReel(0); startReel(1); startReel(2);
  setTimeout(()=>{ stopReel(0,result[0]); if(result[0]===SYM.BONUS3) safePlay(SFX.base3); },1200);
  setTimeout(()=>{
    stopReel(1,result[1]);
    const has3=(result[0]===SYM.BONUS3), has32=(has3 && result[1]===SYM.BONUS2);
    if(has32){
      safePlay(SFX.base2); safePlay(SFX.base2Ant);
      echoEl.style.display='block'; r3Hex.classList.add('teasing');
      const nearMiss = result[2] !== SYM.BONUS1; if(nearMiss) r3Hex.classList.add('teasing-strong');
      setTimeout(()=>finishR3(result),1800);
    } else finishR3(result);
  },2500);
}
function finishR3(result){
  setTimeout(()=>{
    stopReel(2,result[2]); safeStop(SFX.reelSpinMusic);
    echoEl.style.display='none'; r3Hex.classList.remove('teasing','teasing-strong');
    const isBonus=(result[0]===SYM.BONUS3 && result[1]===SYM.BONUS2 && result[2]===SYM.BONUS1);
    if(isBonus){ gameRoot.classList.add('border-flash'); setTimeout(()=>gameRoot.classList.remove('border-flash'),900); if (!state.precogActive) safePlay(SFX.base1Contact); enterBonus(); }
    else scoreBase(result);
  },1500);
}
function scoreBase(result){
  let payout=0;
  for(const [sym,pay] of Object.entries(PAYS_3OAK)){
    let matches=0;
    for(let i=0;i<3;i++){ if(result[i]===sym || (result[i]===SYM.WILD && sym!==SYM.WILD)) matches++; }
    if(matches===3){ payout=pay*bet(); break; }
  }
  if(payout>0){ hexes.forEach(h=>h.classList.add('winning')); flashWin(`WIN ${payout} CREDITS`); }
  countUpWin(payout,{ onDone:()=>{ hexes.forEach(h=>h.classList.remove('winning')); state.spinning=false; setUI(true);} });
}
function startWaitLoop() {
  if (!audioEnabled) return;
  if (isWaitLoopPlaying) return;        // <-- prevents double loop
  try {
    safeStop(SFX.fgWaitLoop);           // ensure clean start
    SFX.fgWaitLoop.currentTime = 0;
    SFX.fgWaitLoop.loop = true;         // loop the entire file
    SFX.fgWaitLoop.play().catch(()=>{});
    isWaitLoopPlaying = true;
  } catch {}
}

function stopWaitMusic() {
  try {
    SFX.fgWaitIntro.onended = null;     // no stray handoff
  } catch {}
  safeStop(SFX.fgWaitIntro);
  safeStop(SFX.fgWaitLoop);
  isWaitLoopPlaying = false;
}

function enterBonus(){
  state.inBonus = true;
  setUI(true);
  safePlay(SFX.fgTrans);

  // Play the short intro once, then LOOP the entire wait loop file
  stopWaitMusic(); // reset any previous state
  safePlay(SFX.fgWaitIntro, { loop:false, restart:true });

  SFX.fgWaitIntro.onended = () => {
    SFX.fgWaitIntro.onended = null;
    // still on the wait screen?
    if (state.inBonus && !document.getElementById('startBonus').disabled) {
      startWaitLoop(); // guarded: won’t double-start
    }
  };

  playfieldInner.classList.add('zoomed');
  setTimeout(()=>{ bonusIntro.classList.add('show','pulse'); },1000);
}

startBonusBtn.addEventListener('click', ()=>{
  bonusIntro.classList.remove('show','pulse');

  stopWaitMusic(); // <-- stops intro and/or the loop, clears onended, resets guard

  safePlay(SFX.fgLoop,{ loop:true, restart:false }); // bonus background loop
  playfieldInner.classList.add('flipped');
  setTimeout(()=>{ 
    playfieldInner.classList.remove('zoomed'); 
    setTimeout(()=>{ startFreeSpins(); },600); 
  },1200);
});


function startFreeSpins(){
  state.bonusSpins=10; 
  state.bonusTotal=0;
  fsLeft.style.display='block';
  fsRight.style.display='block';
  fsLeft.classList.add('rotating');   // <— start rotation
  updateBonusHUD();
  if (SFX.fgLoop.paused) {
    safePlay(SFX.fgLoop,{ loop:true, restart:false });
  }
  nextFreeSpin();
}

function updateBonusHUD() {
  // clamp to 0..10 and build FS_00..FS_10
  const n = Math.max(0, Math.min(10, state.bonusSpins));
  const file = `FS_${String(n).padStart(2, '0')}.png`;
  const newSrc = `./assets/${file}`;

  // Update right-side text meter as before
  fsRight.textContent = `Win: ${toCurrency(state.bonusTotal)}`;

  // First show: no animation, just set both faces
  if (lastFsCount === null) {
    fsSpinImage.src = newSrc;
    fsSpinImage.alt = `Spins: ${n}`;
    fsSpinImageBack.src = newSrc;
    lastFsCount = n;
    return;
  }

  // If the number didn't change, do nothing
  if (n === lastFsCount) return;

  // Prepare the BACK face with the new image
  fsSpinImageBack.src = newSrc;
  fsSpinImageBack.alt = `Spins: ${n}`;

  // Restart the one-off 360° flip
  fsFlip.classList.remove('animating');
  void fsFlip.offsetWidth; // reflow to restart animation
  fsFlip.classList.add('animating');

  // Mid-flip swap: when we reach ~180°, replace the hidden FRONT src so it ends correct at 360°
  clearTimeout(fsFlip._midSwap);
  fsFlip._midSwap = setTimeout(() => {
    fsSpinImage.src = newSrc;      // swap while the front face is hidden
    fsSpinImage.alt = `Spins: ${n}`;
  }, FS_SPIN_MS / 2);

  // Cleanup at the end of the animation
  const onEnd = () => {
    fsFlip.classList.remove('animating'); // reset transform to 0deg for next time
    fsFlip.removeEventListener('animationend', onEnd);
  };
  fsFlip.addEventListener('animationend', onEnd);

  lastFsCount = n;
}



// === JACKPOT VIDEO OVERLAY HELPERS (replaces the old popup-based section) ===

// Expect these elements from the new HTML overlay you added earlier:
const jackpotOverlay = document.getElementById('jackpotOverlay');     // <div id="jackpotOverlay">
const jackpotVideo   = document.getElementById('jackpotVideo');       // <video id="jackpotVideo">
const jackpotCounterMount = document.getElementById('jackpotCounterMount'); // <div id="jackpotCounterMount">


// Plays the WEBM behind a count-up overlay; returns a Promise that resolves when it’s done.
function showJackpotCelebration(jackpotType, amount, multiplier = 1) {
  return new Promise((resolve) => {
    // 1) Stop bonus loop while the video (with its own audio) plays. Do NOT start big-win loop.
    safeStop(SFX.fgLoop);
    safeStop(SFX.fgBigWinLoop); // just in case

    // 2) Prepare overlay
    jackpotOverlay.classList.remove('overlay-hidden');
    jackpotOverlay.classList.add('overlay-show');

    // 3) Create a lightweight counter element (so we don't depend on the old box DOM)
const stack = document.createElement('div');
stack.id = 'jackpotCounterStack';
stack.style.position = 'absolute';
stack.style.left = '50%';
stack.style.top = '45%'; // move the count-down lower; tweak 60–72% to taste
stack.style.transform = 'translate(-50%, -50%)';
stack.style.display = 'grid';
stack.style.placeItems = 'center';

const counter = document.createElement('div');
counter.id = 'jackpotCountUp';
counter.style.fontSize = '88px';
counter.style.fontWeight = '900';
counter.style.textShadow = '0 0 30px rgba(0,0,0,0.75), 0 0 30px rgba(255,255,255,0.5)';
counter.style.userSelect = 'none';

stack.appendChild(counter);
jackpotCounterMount.appendChild(stack);

// 4) Count-up timing: start late, end together with the video
const finalAmount = Math.floor((amount || 0) * (multiplier || 1));

// TUNABLE KNOBS:
const COUNT_DELAY_MS = 1000;   // roll-up appears 1s after video starts
const TOTAL_COUNT_MS = 10000;  // total time the number animates (incl. the delay)
const FADE_OUT_MS    = 800;    // fade duration of the roll-up at the end

// Derived: actual “moving” duration once it appears
const startTs  = performance.now() + COUNT_DELAY_MS;
const duration = Math.max(300, TOTAL_COUNT_MS - COUNT_DELAY_MS);

let countDone = false;

function frame(now) {
  const p = Math.min(1, (now - startTs) / duration);
  if (p <= 0) { requestAnimationFrame(frame); return; }
  const cur = Math.floor(finalAmount * p);
  counter.textContent = toCurrency(cur);
  if (p < 1) {
    requestAnimationFrame(frame);
  } else {
    countDone = true;
    // don't finish here; wait for the video to end so they land together
    if (jackpotVideo.ended) finish();
  }
}

// 5) Load & play the correct WEBM (unchanged), but schedule the fade + end sync
const src = getJackpotVideoFilename(
  (String(jackpotType || '').toLowerCase() === 'mini')  ? 'Mini'  :
  (String(jackpotType || '').toLowerCase() === 'minor') ? 'Minor' :
  (String(jackpotType || '').toLowerCase() === 'major') ? 'Major' :
  (String(jackpotType || '').toLowerCase() === 'grand') ? 'Grand' : 'Major',
  multiplier
);


    // Make sure video audio plays (don’t mute). Keep playsinline; no loop.
    jackpotVideo.removeAttribute('muted');
    jackpotVideo.setAttribute('playsinline', '');
    jackpotVideo.loop = false;
    jackpotVideo.src = src;
    jackpotVideo.load();

    // Set up finish/cleanup
    let finished = false;
    function finish() {
      if (finished) return;
      finished = true;

      // Clean overlay
      jackpotOverlay.classList.remove('overlay-show');
      jackpotOverlay.classList.add('overlay-hidden');

      // Remove counter stack
      try { jackpotCounterMount.removeChild(stack); } catch(_) {}

      // Reset video
      jackpotVideo.removeAttribute('src');
      jackpotVideo.load();

      // Resume bonus loop (if still in bonus spins)
      if (state.inBonus && state.bonusSpins > 0) {
        safePlay(SFX.fgLoop, { loop: true, restart: false });
      }

      resolve();
    }

    // If video ends before count-up, wait for the count-up to finish; if count-up ends first, finish after the 2s hold.
    jackpotVideo.onended = () => { if (countDone) finish(); };
    jackpotVideo.onerror = () => {
      // If the video fails, we still honor the count-up timing
      console.warn('Jackpot video failed to load:', src);
      // nothing else to do; finish() will be driven by the counter timing
    };

    // Start both
    jackpotVideo.play()
      .catch(err => console.warn('Autoplay/playback issue:', err));
    requestAnimationFrame(frame);

    // Safety timeout (video length unknown): hard cap at 16s (12s + 2s hold + buffer)
    setTimeout(() => { if (countDone) finish(); }, 16000);
  });
}


function showBonusSpinWin(amount) {
  bonusWinAmount.textContent = toCurrency(amount);
  bonusWinDisplay.classList.add('show');

  return new Promise(resolve => {
    // keep your current visible time (you can tweak 3000 later if desired)
    const visibleMs = 3000;
    setTimeout(() => {
      bonusWinDisplay.classList.remove('show');

      // wait for CSS to actually hide; 200ms is safe for the transition (no transition? it resolves immediately)
      setTimeout(resolve, 200);
    }, visibleMs);
  });
}

function clearFuseEffect(){ wire1.classList.remove('fuse'); wire2.classList.remove('fuse'); wire3.classList.remove('fuse'); wire4.classList.remove('fuse'); }
function nextFreeSpin(){
  if(state.bonusSpins<=0){ endBonus(); return; }
  state.bonusSpins--; updateBonusHUD(); clearFuseEffect(); bonusHexes.forEach(h => h.classList.remove('winning'));

  let results;
  if(DEBUG.forceBonusWin){
    results=[ {type:'cash',mult:10,file:getCashFilename(10, bet())}, {type:'multi',mult:2,file:'fg_2x.png'}, {type:'jackpot',name:DEBUG.forceBonusWin,file:`fg_${DEBUG.forceBonusWin}.png`} ];
    DEBUG.forceBonusWin=null;
  } else results=[getBonusResult(),getBonusResult(),getBonusResult()];
  startReel(0,true); startReel(1,true); startReel(2,true);
  setTimeout(()=>stopReel(0,results[0].file,true),1200);
  setTimeout(()=>stopReel(1,results[1].file,true),2500);
  setTimeout(()=>{ stopReel(2,results[2].file,true); settleBonusSpin(results); },3800);
}
function settleBonusSpin(results) {
  if (!results.every(r => r.type !== 'blank')) {
    // blanks → just go
    setTimeout(nextFreeSpin, 1500);
    return;
  }

  // Fuse timing unchanged
  setTimeout(() => wire1.classList.add('fuse'), 100);
  setTimeout(() => wire2.classList.add('fuse'), 500);
  setTimeout(() => wire3.classList.add('fuse'), 900);
  setTimeout(() => wire4.classList.add('fuse'), 900);

  let spinWin = 0, mult = 1;
  const jackpotsWon = [];
  // Mark winning reels: any non-blank symbol that contributed this spin
  if (!results.some(r => r.type === 'blank')) {
  results.forEach((r, i) => {
    if (r.type === 'cash' || r.type === 'jackpot' || r.type === 'multi') {
      bonusHexes[i].classList.add('winning');
    }
  });
}

// Tally the 3 symbols
const files = results.map(r => r.file);

// Determine components
const hasBlank   = results.some(r => r.type === 'blank');
const hasMulti   = results.some(r => r.type === 'multi');
const jackpots   = results.filter(r => r.type === 'jackpot');
const cashCells  = results.filter(r => r.type === 'cash');

// Must “make contact”: all three positions valid (no blank)
if (!hasBlank) {
  // Multiplier (bonus uses only 2x when present)
// Stack all 2x symbols multiplicatively: 1=×2, 2=×4, 3=×8, ...
const multiCount = results.reduce((n, r) => n + (r.type === 'multi' ? 1 : 0), 0);

// OPTIONAL: cap stacking (uncomment if you want a maximum, e.g. 3 doublers -> max ×8)
// const MAX_DOUBLERS = 3;
// const effectiveCount = Math.min(multiCount, MAX_DOUBLERS);
// const mult = 2 ** effectiveCount;

const mult = 2 ** multiCount;  // no cap

  // Add cash values (files are like fg_1500.png where 1500 = cents)
  for (const c of cashCells) {
    // parse number from filename e.g. fg_1500.png -> 1500
    const m = /fg_(\d+)\.png$/.exec(c.file);
    if (m) spinWin += parseInt(m[1], 10);
  }

  // Add jackpots (fixed values in cents)
  for (const j of jackpots) {
    const amount = JACKPOT_VALUES[j.name]; // e.g. mini/minor/major/grand
    jackpotsWon.push({ type: j.name, amount: amount });
    spinWin += amount;
  }

  // Apply multiplier to the entire spin win
  spinWin *= mult;
}
  state.bonusTotal += spinWin;
  updateBonusHUD();

if (jackpotsWon.length > 0) {
  // Pick the largest jackpot (amount already in cents)
  const biggestJackpot = jackpotsWon.reduce((a, b) => (b.amount > a.amount ? b : a));

  // Play the WEBM + count-up; resume only when it finishes
  showJackpotCelebration(biggestJackpot.type, biggestJackpot.amount, mult)
    .then(() => nextFreeSpin());
} else {
  if (spinWin > 0) {
    const DELAY_BEFORE_WIN_BOX_MS = 800; // give visibility to reel 3
    setTimeout(() => {
      showBonusSpinWin(spinWin).then(() => { nextFreeSpin(); });
    }, DELAY_BEFORE_WIN_BOX_MS);
  } else {
    setTimeout(() => { nextFreeSpin(); }, 1200);
  }
}

}

function endBonus(){
  safeStop(SFX.fgLoop); safePlay(SFX.fgOutro);
  fsLeft.style.display='none'; fsRight.style.display='none';
  bigWinDisplay.classList.add('show'); bigWinAmount.textContent='0';
  const start=performance.now(), duration=6000, total=state.bonusTotal;
  function frame(now){
    const p=Math.min(1,(now-start)/duration), cur=Math.floor(total*p);
    bigWinAmount.textContent=toCurrency(cur);
    if(p<1) requestAnimationFrame(frame);
    else {
      setTimeout(()=>{
        bigWinDisplay.classList.remove('show');
        playfieldInner.classList.add('zoomed');
        setTimeout(()=>{
          playfieldInner.classList.remove('flipped');
          setTimeout(()=>{
            playfieldInner.classList.remove('zoomed');
            state.credits+=total; state.win=total; updateMeters(); state.inBonus=false; state.spinning=false; setUI(true);
          },1200);
        },600);
      },1000);
    }
  }
  requestAnimationFrame(frame);
}

function flash(msg){ const b=document.createElement('div'); b.className='banner show'; b.style.borderColor='#ffaa00'; b.textContent=msg; gameRoot.appendChild(b); setTimeout(()=>b.remove(),1000); }
function flashWin(msg){ const b=document.createElement('div'); b.className='banner show'; b.style.borderColor='#2ecc71'; b.textContent=msg; gameRoot.appendChild(b); setTimeout(()=>b.remove(),1100); }

paytableBtn.onclick=()=>paytable.classList.add('show'); closePTBtn.onclick=()=>paytable.classList.remove('show'); spinBtn.onclick=handleSpinClick;
document.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();

  // NEW: number keys 1–9 = force a 3OAK base hit for testing
  if (LINE_TEST_MAP[k]) {
    DEBUG.forceSymbolsOnce = [LINE_TEST_MAP[k], LINE_TEST_MAP[k], LINE_TEST_MAP[k]];
    // quick “gaffe” flash so you know it armed
    gameRoot.classList.add('border-flash');
    setTimeout(() => gameRoot.classList.remove('border-flash'), 900);
    console.log('[Debug] Forcing 3OAK:', LINE_TEST_MAP[k]);
  }

  if (k === 'b') window.forceBonusOnce();
  if (k === 'n') window.forceNearMissOnce();
  if (k === 'j') window.forceJackpot();
  if (k === 'p') {
    window.forcePrecog();
    if (e.shiftKey) {
      window.forceBonusOnce();
      console.log('[Debug] Shift+P: forcing BONUS and PRECOG on next spin');
    } else {
      console.log('[Debug] P: PRECOG flagged; will show only if the next spin is a BONUS');
    }
  }

  // NEW: spacebar triggers SPIN (same as clicking the button)
  if (e.code === 'Space' || k === ' ') {
    e.preventDefault();
    handleSpinClick();
  }
});

updateMeters(); updateBetButtons();
console.log('321 Contact v7 (Fixed) - Debug Keys: B=bonus, N=near-miss, J=grand, P=precog (Shift+P = force bonus+precog)');
</script>
</body>
</html>